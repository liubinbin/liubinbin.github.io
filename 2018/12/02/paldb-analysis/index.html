<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>paldb解读 | BIN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="github地址：https:&#x2F;&#x2F;github.com&#x2F;linkedin&#x2F;PalDB.git 相关内容可以建项目的readme。 主要分析函数如下： StoreWriter的put方法paldb的数据按key对应的byte数组的长度散列。不同key长度会有不同index file和data file。 此方法是paldb写入数据的主流程。 相关代码和一些注释如下： 1234567891011121">
<meta property="og:type" content="article">
<meta property="og:title" content="paldb解读">
<meta property="og:url" content="http://example.com/2018/12/02/paldb-analysis/index.html">
<meta property="og:site_name" content="BIN">
<meta property="og:description" content="github地址：https:&#x2F;&#x2F;github.com&#x2F;linkedin&#x2F;PalDB.git 相关内容可以建项目的readme。 主要分析函数如下： StoreWriter的put方法paldb的数据按key对应的byte数组的长度散列。不同key长度会有不同index file和data file。 此方法是paldb写入数据的主流程。 相关代码和一些注释如下： 1234567891011121">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/paldb-file-format.jpeg">
<meta property="article:published_time" content="2018-12-02T15:47:20.000Z">
<meta property="article:modified_time" content="2019-01-03T11:40:37.797Z">
<meta property="article:author" content="binbin liu">
<meta property="article:tag" content="src">
<meta property="article:tag" content="paldb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/paldb-file-format.jpeg">
  
    <link rel="alternate" href="/atom.xml" title="BIN" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">BIN</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">a blog of bin</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-paldb-analysis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/12/02/paldb-analysis/" class="article-date">
  <time class="dt-published" datetime="2018-12-02T15:47:20.000Z" itemprop="datePublished">2018-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      paldb解读
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>github地址：<a target="_blank" rel="noopener" href="https://github.com/linkedin/PalDB.git">https://github.com/linkedin/PalDB.git</a></p>
<p>相关内容可以建项目的readme。</p>
<p>主要分析函数如下：</p>
<h1 id="StoreWriter的put方法"><a href="#StoreWriter的put方法" class="headerlink" title="StoreWriter的put方法"></a>StoreWriter的put方法</h1><p>paldb的数据按key对应的byte数组的长度散列。不同key长度会有不同index file和data file。</p>
<p>此方法是paldb写入数据的主流程。</p>
<p>相关代码和一些注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">byte</span>[] key, <span class="type">byte</span>[] value)</span></span><br><span class="line">     <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">keyLength</span> <span class="operator">=</span> key.length;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取indexfile的stream，如果在indexFiles数组和indexStreams数组没有对应key长度索引文件则创建。</span></span><br><span class="line">   <span class="type">DataOutputStream</span> <span class="variable">indexStream</span> <span class="operator">=</span> getIndexStream(keyLength);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在stream中写入key。</span></span><br><span class="line">   indexStream.write(key);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断此key对应长度的最后一个插入的值是否和目前值一致。不明白此处的判断意义。</span></span><br><span class="line">   <span class="type">byte</span>[] lastValue = lastValues[keyLength];</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">sameValue</span> <span class="operator">=</span> lastValue != <span class="literal">null</span> &amp;&amp; Arrays.equals(value, lastValue);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取对应的长度已写入的数据的长度，这个值在后续close时会使用到。</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">dataLength</span> <span class="operator">=</span> dataLengths[keyLength];</span><br><span class="line">   <span class="keyword">if</span> (sameValue) &#123;</span><br><span class="line">     dataLength -= lastValuesLength[keyLength];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 在indexStream写入的长度（就是的value的offset），获取offset的长度，，并在maxOffsetLengths记录当前key长度的最大offset的长度，此数值在后面的计算slot时会使用到。</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">offsetLength</span> <span class="operator">=</span> LongPacker.packLong(indexStream, dataLength);</span><br><span class="line">   System.out.println(<span class="string">&quot;offsetLength: &quot;</span> + offsetLength + <span class="string">&quot; maxOffsetLengths[keyLength]: &quot;</span> + maxOffsetLengths[keyLength]);</span><br><span class="line">   maxOffsetLengths[keyLength] = Math.max(offsetLength, maxOffsetLengths[keyLength]);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 只有sameValue为false时才执行下面的命令：</span></span><br><span class="line">   <span class="keyword">if</span> (!sameValue) &#123;</span><br><span class="line">     <span class="comment">// 获取datafile的stream，如果在dataFiles数组和dataStreams数组没有对应key长度索引文件则创建。</span></span><br><span class="line">     <span class="type">DataOutputStream</span> <span class="variable">dataStream</span> <span class="operator">=</span> getDataStream(keyLength);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 在datastream写入value长度和value值</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">valueSize</span> <span class="operator">=</span> LongPacker.packInt(dataStream, value.length);</span><br><span class="line">     dataStream.write(value);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 更新数据长度，此处可以认为是在datastream里的offset，在后续close时会使用到。</span></span><br><span class="line">     dataLengths[keyLength] += valueSize + value.length;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 更新最后一个插入值的信息，在lastValues和lastValuesLength中。</span></span><br><span class="line">     lastValues[keyLength] = value;</span><br><span class="line">     lastValuesLength[keyLength] = valueSize + value.length;</span><br><span class="line">  <span class="comment">// 更新所有插入的value的count计数</span></span><br><span class="line">     valueCount++;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 更新key的count计数, 此数和valueCount不一定一致。</span></span><br><span class="line">   keyCount++;</span><br><span class="line">   keyCounts[keyLength]++;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="StoreWriter的close方法"><a href="#StoreWriter的close方法" class="headerlink" title="StoreWriter的close方法"></a>StoreWriter的close方法</h1><p>此方法为close方法，主要整理了从打卡到目前为止的临时数据。</p>
<p>相关代码和一些注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 关闭data file和index file的stream</span></span><br><span class="line">  <span class="keyword">for</span> (DataOutputStream dos : dataStreams) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dos != <span class="literal">null</span>) &#123;</span><br><span class="line">      dos.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (DataOutputStream dos : indexStreams) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dos != <span class="literal">null</span>) &#123;</span><br><span class="line">      dos.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stats</span></span><br><span class="line">  LOGGER.log(Level.INFO, <span class="string">&quot;Number of keys: &#123;0&#125;&quot;</span>, keyCount);</span><br><span class="line">  LOGGER.log(Level.INFO, <span class="string">&quot;Number of values: &#123;0&#125;&quot;</span>, valueCount);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个list变量filesToMerge来存储要merge的文件，包括meta文件，index文件，data文件</span></span><br><span class="line">  List&lt;File&gt; filesToMerge = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;File&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写metadata文件（以metadata.dat结尾）</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">metadataFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(tempFolder, <span class="string">&quot;metadata.dat&quot;</span>);</span><br><span class="line">    metadataFile.deleteOnExit();</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">metadataOututStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(metadataFile);</span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">metadataDataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(metadataOututStream);</span><br><span class="line">    writeMetadata(metadataDataOutputStream);</span><br><span class="line">    metadataDataOutputStream.close();</span><br><span class="line">    metadataOututStream.close();</span><br><span class="line">    filesToMerge.add(metadataFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建索引文件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; indexFiles.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (indexFiles[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 按的key长度索引文件。</span></span><br><span class="line">        filesToMerge.add(buildIndex(i));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stats collisions</span></span><br><span class="line">    LOGGER.log(Level.INFO, <span class="string">&quot;Number of collisions: &#123;0&#125;&quot;</span>, collisions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把数据文件加入到filesToMerge文件</span></span><br><span class="line">    <span class="keyword">for</span> (File dataFile : dataFiles) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dataFile != <span class="literal">null</span>) &#123;</span><br><span class="line">        filesToMerge.add(dataFile);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查磁盘空间</span></span><br><span class="line">    checkFreeDiskSpace(filesToMerge);</span><br><span class="line">    <span class="comment">// merge三类文件值一个文件outputStream中。</span></span><br><span class="line">    mergeFiles(filesToMerge, outputStream);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭outputStream，删除临时文件（filesToMerge）</span></span><br><span class="line">    outputStream.close();</span><br><span class="line">    cleanup(filesToMerge);</span><br><span class="line">    <span class="comment">// 最终所有的数据合并在outputStream（也就是我们指出的文件中）中。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="StoreWriter的writeMetadata方法"><a href="#StoreWriter的writeMetadata方法" class="headerlink" title="StoreWriter的writeMetadata方法"></a>StoreWriter的writeMetadata方法</h1><p>此方法为写meta部分的代码，从中可以看到meta部分的结构。</p>
<p>相关代码和一些注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeMetadata</span><span class="params">(DataOutputStream dataOutputStream)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 写入版本信息</span></span><br><span class="line">  dataOutputStream.writeUTF(FormatVersion.getLatestVersion().name());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入当前时间</span></span><br><span class="line">  dataOutputStream.writeLong(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取对应长度有值的个数和目前key长度的最大</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">keyLengthCount</span> <span class="operator">=</span> getNumKeyCount();</span><br><span class="line">  <span class="type">int</span> <span class="variable">maxKeyLength</span> <span class="operator">=</span> keyCounts.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入key个数</span></span><br><span class="line">  dataOutputStream.writeInt(keyCount);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入获取到的有值的key长度的个数keyLengthCount</span></span><br><span class="line">  dataOutputStream.writeInt(keyLengthCount);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入获取到key长度最大值maxKeyLength</span></span><br><span class="line">  dataOutputStream.writeInt(maxKeyLength);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化datasLength</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">datasLength</span> <span class="operator">=</span> <span class="number">0l</span>;</span><br><span class="line">  <span class="comment">// 针对每个key长度有值的长度执行如下命令</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; keyCounts.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 判断是否有此长度的key</span></span><br><span class="line">    <span class="keyword">if</span> (keyCounts[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 写入长度</span></span><br><span class="line">      dataOutputStream.writeInt(i);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 写入key的个数</span></span><br><span class="line">      dataOutputStream.writeInt(keyCounts[i]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 写入slot个数（有key的个数除以loadFactor，loadFactor默认为0.75），此slot用于包含数据。</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">slots</span> <span class="operator">=</span> (<span class="type">int</span>) Math.round(keyCounts[i] / loadFactor);</span><br><span class="line">      dataOutputStream.writeInt(slots);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 以下四步记录各个部分key对应的index和data的offset。</span></span><br><span class="line">      <span class="comment">// 写入slot大小(key长度 + 最大offset的长度)</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">offsetLength</span> <span class="operator">=</span> maxOffsetLengths[i];</span><br><span class="line">      dataOutputStream.writeInt(i + offsetLength);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 写入index的offset</span></span><br><span class="line">      dataOutputStream.writeInt((<span class="type">int</span>) indexesLength);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 偏移此长度对应的index需要的offset偏移</span></span><br><span class="line">      indexesLength += (i + offsetLength) * slots;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 写入数据长度</span></span><br><span class="line">      dataOutputStream.writeLong(datasLength);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 偏移本长度对应的data需要的offset偏移</span></span><br><span class="line">      datasLength += dataLengths[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入序列化信息</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Serializers.serialize(dataOutputStream, config.getSerializers());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入最终文件中index部分的offset和data部分的offset。index通过目前再加两个值的offset开始，data部分从在index之后再写完所有index的长度开始。</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">indexOffset</span> <span class="operator">=</span> dataOutputStream.size() + (Integer.SIZE / Byte.SIZE) + (Long.SIZE / Byte.SIZE);</span><br><span class="line">  dataOutputStream.writeInt(indexOffset);</span><br><span class="line">  dataOutputStream.writeLong(indexOffset + indexesLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="StoreWriter的buildIndex方法"><a href="#StoreWriter的buildIndex方法" class="headerlink" title="StoreWriter的buildIndex方法"></a>StoreWriter的buildIndex方法</h1><p>此方法为buildindex，可以看到paldb怎么获取offset，怎么做冲突等。</p>
<p>相关代码和一些注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> File <span class="title function_">buildIndex</span><span class="params">(<span class="type">int</span> keyLength)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 初始化count（本长度key的个数），slots个数，offsetLength，slotSize(key长度+offset长度)</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> keyCounts[keyLength];</span><br><span class="line">  <span class="type">int</span> <span class="variable">slots</span> <span class="operator">=</span> (<span class="type">int</span>) Math.round(count / loadFactor);</span><br><span class="line">  <span class="type">int</span> <span class="variable">offsetLength</span> <span class="operator">=</span> maxOffsetLengths[keyLength];</span><br><span class="line">  <span class="type">int</span> <span class="variable">slotSize</span> <span class="operator">=</span> keyLength + offsetLength;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化index文件，此index文件没有temp</span></span><br><span class="line">  <span class="type">File</span> <span class="variable">indexFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(tempFolder, <span class="string">&quot;index&quot;</span> + keyLength + <span class="string">&quot;.dat&quot;</span>);</span><br><span class="line">  <span class="type">RandomAccessFile</span> <span class="variable">indexAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(indexFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    indexAccessFile.setLength(slots * slotSize);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">indexChannel</span> <span class="operator">=</span> indexAccessFile.getChannel();</span><br><span class="line">    <span class="comment">// 使用了一个MappedByteBuffer</span></span><br><span class="line">    <span class="type">MappedByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> indexChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, indexAccessFile.length());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化临时index文件的用于读的流</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">tempIndexFile</span> <span class="operator">=</span> indexFiles[keyLength];</span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">tempIndexStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(tempIndexFile)));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">byte</span>[] keyBuffer = <span class="keyword">new</span> <span class="title class_">byte</span>[keyLength];</span><br><span class="line">      <span class="type">byte</span>[] slotBuffer = <span class="keyword">new</span> <span class="title class_">byte</span>[slotSize];</span><br><span class="line">      <span class="type">byte</span>[] offsetBuffer = <span class="keyword">new</span> <span class="title class_">byte</span>[offsetLength];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理所有的key，由于slot为key个数除以一个系数，系统小于1，所以slot肯定可以放下所有的数据，如果slot过于，冲突会少，但是更多多余的空间会被浪费。</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 读取key</span></span><br><span class="line">        tempIndexStream.readFully(keyBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取的offset</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> LongPacker.unpackLong(tempIndexStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算hash值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">hash</span> <span class="operator">=</span> (<span class="type">long</span>) hashUtils.hash(keyBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">collision</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 用一个探针去试探，检测冲突，这同时也是在散列。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">probe</span> <span class="operator">=</span> <span class="number">0</span>; probe &lt; count; probe++) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> (<span class="type">int</span>) ((hash + probe) % slots);</span><br><span class="line">          byteBuffer.position(slot * slotSize);</span><br><span class="line">          byteBuffer.get(slotBuffer);</span><br><span class="line"></span><br><span class="line">          <span class="type">long</span> <span class="variable">found</span> <span class="operator">=</span> LongPacker.unpackLong(slotBuffer, keyLength);</span><br><span class="line">          <span class="comment">// 去试探的对应的位置是否有数据</span></span><br><span class="line">          <span class="keyword">if</span> (found == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有值，则说明没有冲突，写入key和offset。</span></span><br><span class="line">            byteBuffer.position(slot * slotSize);</span><br><span class="line">            byteBuffer.put(keyBuffer);</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> LongPacker.packLong(offsetBuffer, offset);</span><br><span class="line">            byteBuffer.put(offsetBuffer, <span class="number">0</span>, pos);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果有值说明有冲突，则标记。</span></span><br><span class="line">            collision = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// Check for duplicates</span></span><br><span class="line">            <span class="keyword">if</span> (Arrays.equals(keyBuffer, Arrays.copyOf(slotBuffer, keyLength))) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                      String.format(<span class="string">&quot;A duplicate key has been found for for key bytes %s&quot;</span>, Arrays.toString(keyBuffer)));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">// 统计冲突个数</span></span><br><span class="line">        <span class="keyword">if</span> (collision) &#123;</span><br><span class="line">          collisions++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;  Max offset length: &quot;</span> + offsetLength + <span class="string">&quot; bytes&quot;</span> +</span><br><span class="line">              <span class="string">&quot;\n  Slot size: &quot;</span> + slotSize + <span class="string">&quot; bytes&quot;</span>;</span><br><span class="line"></span><br><span class="line">      LOGGER.log(Level.INFO, <span class="string">&quot;Built index file &#123;0&#125;\n&quot;</span> + msg, indexFile.getName());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 关闭临时index文件输入流</span></span><br><span class="line">      tempIndexStream.close();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 关闭index文件的channel，释放资源。</span></span><br><span class="line">      indexChannel.close();</span><br><span class="line">      indexChannel = <span class="literal">null</span>;</span><br><span class="line">      byteBuffer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 删除临时index文件</span></span><br><span class="line">      <span class="keyword">if</span> (tempIndexFile.delete()) &#123;</span><br><span class="line">        LOGGER.log(Level.INFO, <span class="string">&quot;Temporary index file &#123;0&#125; has been deleted&quot;</span>, tempIndexFile.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 关闭index文件</span></span><br><span class="line">    indexAccessFile.close();</span><br><span class="line">    indexAccessFile = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 手动执行一次gc，所以在这时候不能在jdk参数中关闭手动gc。</span></span><br><span class="line">    System.gc();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> indexFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="StoreReader的get方法"><a href="#StoreReader的get方法" class="headerlink" title="StoreReader的get方法"></a>StoreReader的get方法</h1><p>此方法是paldb读取数据的主流程。</p>
<p>相关代码和一些注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">byte</span>[] get(<span class="type">byte</span>[] key)</span><br><span class="line">     <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">// 获取key的长度，检测key长度是否有数据在</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">keyLength</span> <span class="operator">=</span> key.length;</span><br><span class="line">   <span class="keyword">if</span> (keyLength &gt;= slots.length || keyCounts[keyLength] == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 计算hash值</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">hash</span> <span class="operator">=</span> (<span class="type">long</span>) hashUtils.hash(key);</span><br><span class="line">   <span class="comment">// 获取对应的key长度的slot个数</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">numSlots</span> <span class="operator">=</span> slots[keyLength];</span><br><span class="line">   <span class="comment">// 获取对应的key长度的slot大小</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">slotSize</span> <span class="operator">=</span> slotSizes[keyLength];</span><br><span class="line">   <span class="comment">// 获取index部分的offset</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">indexOffset</span> <span class="operator">=</span> indexOffsets[keyLength];</span><br><span class="line">   <span class="comment">// 获取data部分的offset</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">dataOffset</span> <span class="operator">=</span> dataOffsets[keyLength];</span><br><span class="line"><span class="comment">// 用一个探针去试探对应位置上是否有数据。</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">probe</span> <span class="operator">=</span> <span class="number">0</span>; probe &lt; numSlots; probe++) &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">slot</span> <span class="operator">=</span> (<span class="type">int</span>) ((hash + probe) % numSlots);</span><br><span class="line">     <span class="comment">// slotBuffer 为slotSize的byte数组, 将所有的key+offset打到一个固定大小slot的好处就是我们可以使用slotSize来定位。</span></span><br><span class="line">     indexBuffer.position(indexOffset + slot * slotSize);</span><br><span class="line">     indexBuffer.get(slotBuffer, <span class="number">0</span>, slotSize);</span><br><span class="line">  <span class="comment">// 解析读取出来的对应slot中的数据</span></span><br><span class="line">     <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> LongPacker.unpackLong(slotBuffer, keyLength);</span><br><span class="line">     <span class="comment">// 判断此slot里是否有数据</span></span><br><span class="line">     <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 比较slotBuffer和key是否完全相等</span></span><br><span class="line">     <span class="keyword">if</span> (isKey(slotBuffer, key)) &#123;</span><br><span class="line">       <span class="comment">// mMapData来标记的是否使用MMap</span></span><br><span class="line">       <span class="type">byte</span>[] value = mMapData ? getMMapBytes(dataOffset + offset) : getDiskBytes(dataOffset + offset);</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="StoreReader的getMMapBytes方法"><a href="#StoreReader的getMMapBytes方法" class="headerlink" title="StoreReader的getMMapBytes方法"></a>StoreReader的getMMapBytes方法</h1><p>此方法为启用mmap时读取真实value的方法。</p>
<p>相关代码和一些注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] getMMapBytes(<span class="type">long</span> offset)</span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 一些bytebuffer的操作，暂不详细分析, 主要的是数据不能一下子读取出来，比较麻烦。</span></span><br><span class="line">  <span class="comment">//Read the first 4 bytes to get the size of the data</span></span><br><span class="line">  <span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> getDataBuffer(offset);</span><br><span class="line">  <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> (<span class="type">int</span>) Math.min(<span class="number">5</span>, dataSize - offset);</span><br><span class="line">  <span class="comment">// 获取的size</span></span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="keyword">if</span> (buf.remaining() &gt;= maxLen) &#123;</span><br><span class="line">    <span class="comment">//Continuous read</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> buf.position();</span><br><span class="line">    size = LongPacker.unpackInt(buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used in case of data is spread over multiple buffers</span></span><br><span class="line">    offset += buf.position() - pos;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//The size of the data is spread over multiple buffers</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> maxLen;</span><br><span class="line">    <span class="type">int</span> <span class="variable">off</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    sizeBuffer.reset();</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      buf = getDataBuffer(offset + off);</span><br><span class="line">      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> Math.min(len, buf.remaining());</span><br><span class="line">      buf.get(sizeBuffer.getBuf(), off, count);</span><br><span class="line">      off += count;</span><br><span class="line">      len -= count;</span><br><span class="line">    &#125;</span><br><span class="line">    size = LongPacker.unpackInt(sizeBuffer);</span><br><span class="line">    offset += sizeBuffer.getPos();</span><br><span class="line">    buf = getDataBuffer(offset);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化输出结果</span></span><br><span class="line">  <span class="type">byte</span>[] res = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Check if the data is one buffer</span></span><br><span class="line">  <span class="keyword">if</span> (buf.remaining() &gt;= size) &#123;</span><br><span class="line">    <span class="comment">//Continuous read</span></span><br><span class="line">    buf.get(res, <span class="number">0</span>, size);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="type">int</span> <span class="variable">off</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      buf = getDataBuffer(offset);</span><br><span class="line">      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> Math.min(len, buf.remaining());</span><br><span class="line">      buf.get(res, off, count);</span><br><span class="line">      offset += count;</span><br><span class="line">      off += count;</span><br><span class="line">      len -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="StoreReader的getDiskBytes方法"><a href="#StoreReader的getDiskBytes方法" class="headerlink" title="StoreReader的getDiskBytes方法"></a>StoreReader的getDiskBytes方法</h1><p>此方法为没有启用mmap时读取真实value的方法。</p>
<p>相关代码和一些注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] getDiskBytes(<span class="type">long</span> offset)</span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// seek到对应长度的offset</span></span><br><span class="line">  mappedFile.seek(dataOffset + offset);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从对应长度读取size</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> LongPacker.unpackInt(mappedFile);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化输出结果</span></span><br><span class="line">  <span class="type">byte</span>[] res = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取数据</span></span><br><span class="line">  <span class="keyword">if</span> (mappedFile.read(res) == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="重要成员变量"><a href="#重要成员变量" class="headerlink" title="重要成员变量"></a>重要成员变量</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">indexOffset: index部分的偏移量</span><br><span class="line">dataOffset：data部分的偏移量</span><br><span class="line">slots(int[])：slot个数，用于hash计算</span><br><span class="line">slotSizes(int[])：slot的大小，用于计算offset</span><br><span class="line">indexOffsets(int[])：index部分中每个key长度对应的offset</span><br><span class="line">dataOffsets(int[])：data部分中每个key长度对应的offset</span><br></pre></td></tr></table></figure>

<h1 id="文件格式图"><a href="#文件格式图" class="headerlink" title="文件格式图"></a>文件格式图</h1><p><img src="/paldb-file-format.jpeg"></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>从图中可以知道，paldb的文件主要的分为三个部分，metadata，index和data。</p>
<p>metadata：主要用于描述paldb文件，其中包括了重要成员变量。</p>
<p>index：主要保存了key和对应的offset。在paldb中数据按key长度区分，并提出了一个slot的概念。一个slot包含key和对应的offset（此offset用于在data部分找到真实数据）。slot的长度是固定，所以在index去获取offset时可以，直接使用下标和slotSize的乘积。下标通过对key的hash计算得到，并使用探针的方式去不停尝试获取到正确的下标。相当于在文件中实现了一个hash函数。</p>
<p>data：主要保存了value长度和value具体的值。具体的offset由在index部分获取。在这里的length的字节数是固定的，所以可以拿到offset后就可以解析处value长度和value值。</p>
<h1 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h1><ul>
<li>在创建slot时，不好把握factor计算slot个数。</li>
<li>如果hash特别不均衡，会导致探针试探次数很多，由于每次试探会读取磁盘，代价略高。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/12/02/paldb-analysis/" data-id="cm3sqo3lq001nh46008gs9xnk" data-title="paldb解读" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/paldb/" rel="tag">paldb</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/src/" rel="tag">src</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/12/14/ability-in-profession/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          ability-in-profession
        
      </div>
    </a>
  
  
    <a href="/2018/12/02/install-hadoop-and-hbase-in-mac/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">在macbook的os上直接安装hadoop&amp;hbase</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ability/" rel="tag">ability</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bank/" rel="tag">bank</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/career/" rel="tag">career</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrent/" rel="tag">concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/" rel="tag">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gc/" rel="tag">gc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/" rel="tag">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hbase/" rel="tag">hbase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hdfs/" rel="tag">hdfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/invest/" rel="tag">invest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/job/" rel="tag">job</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/" rel="tag">life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life-reading/" rel="tag">life,reading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mvn/" rel="tag">mvn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/paldb/" rel="tag">paldb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/paper/" rel="tag">paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rcfile/" rel="tag">rcfile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading/" rel="tag">reading</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/src/" rel="tag">src</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/summary/" rel="tag">summary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/writing/" rel="tag">writing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zk/" rel="tag">zk</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ability/" style="font-size: 10px;">ability</a> <a href="/tags/bank/" style="font-size: 10px;">bank</a> <a href="/tags/career/" style="font-size: 12px;">career</a> <a href="/tags/concurrent/" style="font-size: 10px;">concurrent</a> <a href="/tags/flume/" style="font-size: 10px;">flume</a> <a href="/tags/gc/" style="font-size: 10px;">gc</a> <a href="/tags/hadoop/" style="font-size: 12px;">hadoop</a> <a href="/tags/hbase/" style="font-size: 18px;">hbase</a> <a href="/tags/hdfs/" style="font-size: 14px;">hdfs</a> <a href="/tags/invest/" style="font-size: 10px;">invest</a> <a href="/tags/java/" style="font-size: 12px;">java</a> <a href="/tags/job/" style="font-size: 10px;">job</a> <a href="/tags/kafka/" style="font-size: 12px;">kafka</a> <a href="/tags/life/" style="font-size: 20px;">life</a> <a href="/tags/life-reading/" style="font-size: 10px;">life,reading</a> <a href="/tags/mvn/" style="font-size: 10px;">mvn</a> <a href="/tags/paldb/" style="font-size: 10px;">paldb</a> <a href="/tags/paper/" style="font-size: 10px;">paper</a> <a href="/tags/rcfile/" style="font-size: 10px;">rcfile</a> <a href="/tags/reading/" style="font-size: 16px;">reading</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/src/" style="font-size: 12px;">src</a> <a href="/tags/summary/" style="font-size: 10px;">summary</a> <a href="/tags/writing/" style="font-size: 10px;">writing</a> <a href="/tags/zk/" style="font-size: 10px;">zk</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/22/%E4%B8%89%E4%B8%AA%E6%8A%95%E8%B5%84%E6%96%B9%E5%90%91/">三个投资方向</a>
          </li>
        
          <li>
            <a href="/2024/10/10/%E8%82%A1%E7%A5%A8%E6%98%AF%E4%B8%8E%E4%BA%BA%E3%80%81%E4%B8%8E%E6%97%B6%E9%97%B4%E7%9A%84%E6%B8%B8%E6%88%8F/">股票是与人、与时间的游戏</a>
          </li>
        
          <li>
            <a href="/2024/08/15/%E4%BB%8E%E5%90%8E%E6%82%94%E4%B8%AD%E5%AD%A6%E5%88%B0%E4%B8%9C%E8%A5%BF/">从后悔中学到东西</a>
          </li>
        
          <li>
            <a href="/2024/08/13/%E5%90%91%E6%89%80%E6%9C%89%E4%BA%BA%E5%AD%A6%E4%B9%A0/">向所有人学习</a>
          </li>
        
          <li>
            <a href="/2024/08/06/%E3%80%8A%E5%A4%A7%E5%86%B3%E6%88%98%E4%B9%8B%E8%BE%BD%E6%B2%88%E6%88%98%E5%BD%B9%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/">《大决战之辽沈战役》观后感</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 binbin liu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>